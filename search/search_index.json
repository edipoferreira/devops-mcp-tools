{"config":{"lang":["en","pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to MCP DevOps Tools","text":"<p>This is the documentation for the MCP DevOps Tools.</p>"},{"location":"#available-tools","title":"Available Tools","text":"<p>The following tools are available in the <code>DevOpsUtilityCommands</code> MCP server:</p>"},{"location":"#jenkins","title":"Jenkins","text":"<p>These tools require the following environment variables to be set:</p> <ul> <li><code>JENKINS_TOKEN</code>: Your Jenkins API token.</li> <li> <p><code>JENKINS_URL</code>: The base URL of your Jenkins instance (e.g., <code>http://localhost:8080</code>).</p> </li> <li> <p><code>jenkins_api_get(endpoint: str) -&gt; dict</code>: Performs a GET request to the Jenkins API.</p> </li> <li><code>jenkins_api_post(endpoint: str, data: str, content_type: str = \"application/xml\") -&gt; dict</code>: Performs a POST request to the Jenkins API.</li> </ul> <p></p>"},{"location":"#docker","title":"Docker","text":"<ul> <li><code>docker_compose_up(path: str) -&gt; str</code>: Runs <code>docker compose up -d</code> for a given Docker Compose file.</li> <li><code>docker_compose_down(path: str) -&gt; str</code>: Runs <code>docker compose down</code> for a given Docker Compose file.</li> <li><code>docker_compose_logs(path: str, lines: int = 100) -&gt; str</code>: Retrieves logs from a Docker Compose service.</li> <li><code>docker_ps() -&gt; list[dict]</code>: Lists running Docker containers.</li> </ul>"},{"location":"#kubernetes","title":"Kubernetes","text":"<ul> <li><code>get_pods_namespace(ns: str) -&gt; dict</code>: Retrieves all pods in a given Kubernetes namespace.</li> <li><code>get_namespaces() -&gt; dict</code>: Retrieves the list of Kubernetes namespaces.</li> </ul>"},{"location":"#other","title":"Other","text":"<ul> <li><code>divide(a: float, b: float) -&gt; str | float</code>: Divides two numbers.</li> </ul>"},{"location":"workaround/","title":"WSL Workaround for MCP Server","text":"<p>When trying to use the standard method of creating <code>mcp.json</code> in the <code>.vscode</code> folder, I encountered the <code>Connection state: Error spawn .... ENOENT</code> error. After some research, I found that this is a known issue in VS Code, which will be addressed in a future update.</p> <p>You can track the issue here: https://github.com/microsoft/vscode/issues/251308</p>"},{"location":"workaround/#the-workaround","title":"The Workaround","text":"<p>Since the update might take a while, I'm using a temporary workaround in my <code>settings.json</code>. As I use VS Code in WSL and didn't want to modify the Windows <code>settings.json</code>, I'm using the following configuration:</p> <pre><code>\"mcp\": {\n    \"servers\": {\n        \"DevOpsUtilityCommands\": {\n            \"type\": \"stdio\",\n            \"command\": \"wsl.exe\", // Invokes the WSL subsystem\n            \"args\": [\n                \"/home/edipof/Documents/repo/mcp-lab/code/python-mcp/.venv/bin/python\", // Command to be executed inside WSL\n                \"/home/edipof/Documents/repo/mcp-lab/code/python-mcp/server-mcp.py\" // Path inside WSL\n            ]\n        }\n    }\n}\n</code></pre>"},{"location":"workaround/#standard-configuration-for-when-the-issue-is-fixed","title":"Standard Configuration (for when the issue is fixed)","text":"<p>If it weren't for this problem, the <code>mcp.json</code> could be created like this:</p> <pre><code>{\n  \"servers\": {\n    \"DevOpsUtilityCommands\": {\n      \"type\": \"stdio\",\n      \"command\": \"${workspaceFolder}/code/python-mcp/.venv/bin/python\",\n      \"args\": [\n        \"${workspaceFolder}/code/python-mcp/server-mcp.py\"\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"workaround/#important-considerations","title":"Important Considerations","text":"<p>After applying this workaround, everything works as expected. Copilot can detect the MCP server, and I can list Docker containers, execute Kubernetes commands, and even control Jenkins perfectly.</p> <p>A word of caution: These commands are simple and easy to implement, but they must be used with extreme care. In this repository, they are for testing purposes. In an environment with access to critical systems, the best approach is to create highly restrictive functions.</p>"},{"location":"workaround/#future-plans","title":"Future Plans","text":"<p>This repository is a work in progress. I will be adding more tools over time, including a TypeScript version of the MCP server.</p>"},{"location":"pt/","title":"Bem-vindo ao MCP DevOps Tools","text":"<p>Esta \u00e9 a documenta\u00e7\u00e3o para as Ferramentas de DevOps do MCP.</p>"},{"location":"pt/#ferramentas-disponiveis","title":"Ferramentas Dispon\u00edveis","text":"<p>As seguintes ferramentas est\u00e3o dispon\u00edveis no servidor MCP <code>DevOpsUtilityCommands</code>:</p>"},{"location":"pt/#jenkins","title":"Jenkins","text":"<p>Estas ferramentas requerem que as seguintes vari\u00e1veis de ambiente sejam definidas:</p> <ul> <li><code>JENKINS_TOKEN</code>: O seu token da API do Jenkins.</li> <li> <p><code>JENKINS_URL</code>: A URL base da sua inst\u00e2ncia do Jenkins (por exemplo, <code>http://localhost:8080</code>).</p> </li> <li> <p><code>jenkins_api_get(endpoint: str) -&gt; dict</code>: Realiza uma requisi\u00e7\u00e3o GET para a API do Jenkins.</p> </li> <li><code>jenkins_api_post(endpoint: str, data: str, content_type: str = \"application/xml\") -&gt; dict</code>: Realiza uma requisi\u00e7\u00e3o POST para a API do Jenkins.</li> </ul> <p></p>"},{"location":"pt/#docker","title":"Docker","text":"<ul> <li><code>docker_compose_up(path: str) -&gt; str</code>: Executa <code>docker compose up -d</code> para um determinado arquivo Docker Compose.</li> <li><code>docker_compose_down(path: str) -&gt; str</code>: Executa <code>docker compose down</code> para um determinado arquivo Docker Compose.</li> <li><code>docker_compose_logs(path: str, lines: int = 100) -&gt; str</code>: Recupera os logs de um servi\u00e7o do Docker Compose.</li> <li><code>docker_ps() -&gt; list[dict]</code>: Lista os cont\u00eaineres Docker em execu\u00e7\u00e3o.</li> </ul>"},{"location":"pt/#kubernetes","title":"Kubernetes","text":"<ul> <li><code>get_pods_namespace(ns: str) -&gt; dict</code>: Recupera todos os pods em um determinado namespace do Kubernetes.</li> <li><code>get_namespaces() -&gt; dict</code>: Recupera a lista de namespaces do Kubernetes.</li> </ul>"},{"location":"pt/#outros","title":"Outros","text":"<ul> <li><code>divide(a: float, b: float) -&gt; str | float</code>: Divide dois n\u00fameros.</li> </ul>"},{"location":"pt/workaround/","title":"Solu\u00e7\u00e3o para MCP Server no WSL","text":"<p>Ao tentar usar o m\u00e9todo padr\u00e3o de cria\u00e7\u00e3o do <code>mcp.json</code> na pasta <code>.vscode</code>, encontrei o erro <code>Connection state: Error spawn .... ENOENT</code>. Ap\u00f3s alguma pesquisa, descobri que este \u00e9 um problema conhecido no VS Code, que ser\u00e1 resolvido em uma atualiza\u00e7\u00e3o futura.</p> <p>Voc\u00ea pode acompanhar o problema aqui: https://github.com/microsoft/vscode/issues/251308</p>"},{"location":"pt/workaround/#a-solucao","title":"A Solu\u00e7\u00e3o","text":"<p>Como a atualiza\u00e7\u00e3o pode demorar um pouco, estou usando uma solu\u00e7\u00e3o tempor\u00e1ria no meu <code>settings.json</code>. Como uso o VS Code no WSL e n\u00e3o queria modificar o <code>settings.json</code> do Windows, estou usando a seguinte configura\u00e7\u00e3o:</p> <pre><code>\"mcp\": {\n    \"servers\": {\n        \"DevOpsUtilityCommands\": {\n            \"type\": \"stdio\",\n            \"command\": \"wsl.exe\", // Invoca o subsistema WSL\n            \"args\": [\n                \"/home/edipof/Documents/repo/mcp-lab/code/python-mcp/.venv/bin/python\", // Comando a ser executado dentro do WSL\n                \"/home/edipof/Documents/repo/mcp-lab/code/python-mcp/server-mcp.py\" // Caminho dentro do WSL\n            ]\n        }\n    }\n}\n</code></pre>"},{"location":"pt/workaround/#configuracao-padrao-para-quando-o-problema-for-resolvido","title":"Configura\u00e7\u00e3o Padr\u00e3o (para quando o problema for resolvido)","text":"<p>Se n\u00e3o fosse por este problema, o <code>mcp.json</code> poderia ser criado assim:</p> <pre><code>{\n  \"servers\": {\n    \"DevOpsUtilityCommands\": {\n      \"type\": \"stdio\",\n      \"command\": \"${workspaceFolder}/code/python-mcp/.venv/bin/python\",\n      \"args\": [\n        \"${workspaceFolder}/code/python-mcp/server-mcp.py\"\n      ]\n    }\n  }\n}\n</code></pre>"},{"location":"pt/workaround/#consideracoes-importantes","title":"Considera\u00e7\u00f5es Importantes","text":"<p>Depois de aplicar esta solu\u00e7\u00e3o, tudo funciona como esperado. O Copilot consegue detectar o servidor MCP, e eu consigo listar cont\u00eaineres Docker, executar comandos do Kubernetes e at\u00e9 mesmo controlar o Jenkins perfeitamente.</p> <p>Um aviso: Estes comandos s\u00e3o simples e f\u00e1ceis de implementar, mas devem ser usados com extremo cuidado. Neste reposit\u00f3rio, eles s\u00e3o para fins de teste. Em um ambiente com acesso a sistemas cr\u00edticos, a melhor abordagem \u00e9 criar fun\u00e7\u00f5es altamente restritivas.</p>"},{"location":"pt/workaround/#planos-futuros","title":"Planos Futuros","text":"<p>Este reposit\u00f3rio \u00e9 um trabalho em andamento. Adicionarei mais ferramentas ao longo do tempo, incluindo uma vers\u00e3o em TypeScript do servidor MCP.</p>"}]}